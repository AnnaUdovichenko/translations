# Начни изучать F#. Пособие для C# разработчиков

В одном из наших предыдущих постов, "[Почему вам следует использовать F#][why-you-should-use]", перечислены несколько причин, почему F# стоит попробовать уже сегодня. В данной статье мы разберем некоторые основы, необходимые для успешного применения F#. Данный пост предназначен для людей, которые приходят из C#, Java или имеют иной опыт объектно-ориентированного программирования. Понятия, представленны здесь, должны быть уже хорошо знакомы F# программистам.

В данном посте не будут предприниматься попытки показать, как вы можете "переписать" C# код на F#. Это связано с тем, что C# и F# представляют различные парадигмы, что делает каждый язык подходящим для своих собственных целей. Мы думаем, что изучение понятия функционального программирования расширит кругозор и поможет вам быть лучшим программистом. Вы осознаете ценность функционального программирования быстрее, если не будете думать о том, как переписать код из одной парадигмы в другую.

А сейчас пришло время быть любопытным, пытливым, и быть готовым к изучению совершенно новых вещей. Давайте начнем!

# Сразу к различиям

Перед тем как мы приступим к изучению понятий функционального программирования, давайте посмотрим на небольшой пример F# кода и определим несколько мест, в которых F# отличается от C#. Это базовый пример кода на F# с двумя функциями и выводом результата на экран:

```fsharp
let square x = x * x

let sumOfSquares n =
    [1..n] // Создадим список с элементами от 1 до n
    |> List.map square // Возведем в квадрат каждый элемент
    |> List.sum // Просуммируем их!

printfn "Сумма квадратов первых 5 натуральных чисел равна %d" (sumOfSquares 5)
```

Заметим, что здесь нет явного указания типов, отсутствуют точки с запятой или фигурные скобки. Скобки используются в единственном месте: для вызова функции `sumOfSquares` с числом 5 в качестве входного значения и последующего вывода результата на экран. Конвейерный оператор (pipeline operator) используется так же как конвейеры (каналы) в Unix. `square` -- это функция, которая передается напрямую как параметр в функцию `List.map` (такие функции рассматриваются как значения, first-class functions).

Хотя здесь намного больше различий, о которых мы можем поговорить, здесь происходят более глубокие вещи, и именно они являются ключем к пониманию F#.

# Соответствие ключевых понятий C# и ключевых понятий F#

Следующая таблица показывает основные соответствия между некоторым ключевыми понятиями C# и F#. Это умышленно короткое и неполное описание, но так его проще запомнить в начале изучения F#.

| C# и Объектно-Ориентированное Программирование | F# и Функциональное Программирование |
| --- | --- |
| Переменные | Неизменяемые значения |
| Инструкции | Выражения |
| Объекты с методами | Типы и функции |

Быстрая шпаргалка по некоторым терминам:

**Переменные** -- это значения, которые могуть изменяться на месте или варьироваться. Это следует из их названия!

**Неизменяемые значения** -- это значения, которые не могут быть изменены после присваивания.

[**Инструкции**][statements] -- это единицы работы, выполняемые императивно, путем запуска программы.

[**Выражения**][expressions] -- это единицы кода, которые можно вычислить и получить значения.

[**Типы**][types] -- это классификация данных в программе.

Стоит отметить, что все указанное в столбце C# так же возможно в F# (и довольно легко реализуется). В столбце F# так же есть вещи, которые возможны в C#, хотя их намного сложнее достигнуть. Следует упомянуть, что элементы в левом столбце не являются "плохими" в F#, и наоборот. Объекты с методами отлично подходят для использования в F#, и часто являются лучшим решением для F# в зависимости от вашей ситуации.

## Неизменяемые значения вместо переменных

Одним из наиболее преобразующих понятий в функциональном программировании является неизменяемость (immutability). Этому понятию часто уделяют недостаточно внимания в сообществе любителей функционального программирования. Но если вы никогда не использовали язык, в котором значения неизменяемы по умолчанию, то это часто является первым и наиболее значимым препятствием для дальнейшего изучения. Почти все функциональные языки в своем основании имеют неизменяемость.

```fsharp
let x = 1
```

В предыдущем выражении значение 1 связано с именем `x`. В течение всего времени существования имя `x` теперь ссылается на значение 1 и не может быть изменено. Например, следующий код не может переназначить значение `x`:

```fsharp
let x = 1
x = x + 1 // Это выражение ничего не присваивает!
```

Вместо этого, вторая строка является сравнением, определяющим является ли `x` равным `x + 1`. Хотя существует способ изменить (mutate) `x` с помощью использования оператора `<-` и модификатора `mutable` (см. подробности в [Mutable Variables][mutables], вы быстро поймете, что проще думать решении задач без переприсвоения значений. Если вы не будете рассматривать F# как еще один императивный язык программирования, то это позволит вам использовать его самые сильные стороны.

Мы сказали о том, что неизменяемость является преобразующей, и это означает, что существуют практические различия в подходах к решению задач. Например, циклы `for` и другие базовые операции в императивном программировании не так часто используются в F#.

Рассмотрим более конкретный пример, скажем, вы хотите возвести в квадрат числа из входного списка. Вот способ как это можно сделать в F#:

```fsharp
// Определим функцию, которая вычисляет квадрат значения
let square x = x * x

let getSquares items =
    items |> List.map square
	
let lst = [ 1; 2; 3; 4; 5 ] // Создать список в F#

printfn "Квадрат числа %A равен %A" lst (getSquares lst)
```

Заметим, что в этом примере нет цикла `for`. На концептуальном уровне это очень отличается от императивного кода. Мы не возводим в квадрат каждый элемент списка. Мы с помощью функции `square` отображаем входной список, чтобы получить значения, возведенные в квадрат. Это очень тонкое различие, но на практике может приводить к значительно отличающемуся коду. Прежде всего, функция `getSquares` на самом деле создает целиком новый список.

Неизменяемость делает больше, чем просто меняет способ управления данными в списках. Понятие ссылочной прозрачности ([Referential Transparency][ref-transparency]) естественно для F#, и оказывает значительное влияние как на разработку систем, так и на то, как части этих систем сочетаются. Функциональные характеристики системы становятся более предсказумыми, когда значения не изменяются, если вы этого не ожидаете.

Более того, когда значения неизменяемы, конкурентное программирование становится проще. Из-за того, что значения не могут быть изменены, некоторые сложные проблемы, которые вы можете встретить в С#, не встречаются в F#. Хотя F# не решит магическим образом все ваши проблемы с многопоточностью и асинхронностью, он сделает многие вещи проще.

# Выражения вместо инструкций

Как было упомянуто ранее, F# использует выражения (expressions). Это контрастирует с C#, где используются инструкции (statements) практически для всего. Различие между ними может казаться на первый взгляд незначительным, однако есть одна вещь, которую следует держать в голове: выражения производят значения. Инструкции -- нет.

```fsharp
// 'getMessage' -- это функция, и `name` -- ее входной параметр.
let getMessage name =
    if name = "Phillip" then   // 'if' -- это выражение.
        "Hello, Phillip!"      // Эта строка тоже является выражением. Оно возвращает значение
    else
        "Hello, other person!" // То же самое с этой строкой.

let phillipMessage = getMessage "Phillip" // getMessage, при вызове, является выражением. Его значение связано с именем 'phillipMessage'.
let alfMessage = getMessage "Alf" // Это выражение связано с именем 'alfMessage'!
``` 

В предыдущем примере вы можете увидеть несколько вещей, которые отличают F# от императивных языков вроде C#:

- [`if...then...else`][cond-expr] -- это выражение, а не инструкция.
- Каждая ветка выражения `if` возвращает значения, которые в данном случае являются возвращаемыми значениями функции `getMessage`.
- Каждый вызов функции `getMessage` -- это выражение, которое берет строку и возвращает строку.

Хотя это очень отличается от C#, вам скорее всего покажется естественным при написании кода на F#.

Если рассмотреть немного глубже, F# на самом деле использует выражения для моделирования инструкций. Такие выражения возвращают значения типа [`unit`][unit]. `unit` немного похож на `void` в C#:

```fsharp
let names = [ "Alf"; "Vasily"; "Shreyans"; "Jin Sun"; "Moulaye" ]

// Цикл `for`.  Ключевое слово 'do' указывает, что выражение их внутренней области видмости должно иметь тип `unit`.
// Если это не так, то результат выражения неявно игнорируется.
for name in names do
printfn "My name is %s" name // printfn возвращает unit.
```

В предыдущем примере выражения `for`, все имеет тип `unit`. Выражения `unit` -- это выражения, которые не имеют возвращаемого значения.

# Массивы, списки и последовательности в F#

Предыдущие примеры кода использовали массивы и списки F#. В данном разделе разъясняются некоторые подробности.

F# предоставляет несколько типов коллекций и самые распространенные из них -- это массивы, списки и последовательности.

- [Массивы в F#][arrays] -- это массивы .NET. Они изменяемые, что означает, что из значения могут быть изменены на месте. Они вычисляются энергично (eagerly).
- [Списки в F#][lists] -- это неизменяемые односвязные списки. Они могут быть использованы в виде `list patterns` для сопоставлением с образом (pattern matching) в F#. Они вычисляются энергично.
- [Последовательности в F#][seqs] является неизменяемыми `IEnumerable<T>`. Они вычисляются лениво.

Массивы, списки и последовательности в F# также имеют особый синтаксис для выражений. Это очень удобно для различных задач, где вы можете генерировать данные коллекции программным путем.

```fsharp
// Генерировать 100 чисел возведенных в квадрат как F# список.
let first100Squares = [ for x in 1..100 -> x * x ]

// То же самое, но массив!
let first100SquaresArray = [| for x in 1..100 -> x * x |]

// Функция, которая генерирует бесконечную последовательность все нечетные числа.
//
// Вызывать вместе с  Seq.take!
let odds = 
    let rec loop x = // Использует рекурсивную локальную функцию
        seq { yield x
              yield! loop (x + 2) }
    loop 1

printfn "Первые 3 нечетных числа: %A" (Seq.take 3 odds)
// Вывод:  "Первые 3 нечетных числа: seq [1; 3; 5]
```

# Соответствие между LINQ методами и F# функциями

Если вы знакомы с LINQ методами, то следующая таблица поможет вам понять аналогичные функции в F#.

| LINQ | F# функция |
| --- | --- |
| `Where` | `filter` |
| `Select` | `map` |
| `GroupBy` | `groupBy` |
| `SelectMany` | `collect` |
| `Aggregate` | `fold` или `reduce` |
| `Sum` | `sum` |

Вы также можете заметить, что такой же набор функций существует для модуля `Seq`, модуля `List` и модуля `Array`. Функции модуля `Seq` могут быть использованы для последовательностей, спиской или массивов. Функции для массивов и списков могут быть использованы только для массив и списков в F# соответственно. Также последовательности в F# ленивые, а списки и массив -- энергичные. Использование функций модуля `Seq` на списках или массивах влечет за собой ленивое вычисление, а тип возвращаемого значения будет последовательностью.

Хотя предудыщий раздел содержит в себе довольно много всего, это станет интуитивным, когда вы будете больше писать на F#.

# Функциональные конвейеры

Вы могли заметить, что `|>` используется в предыдущих примерах кода. Этот оператор очень похож на конвейеры в unix: он берет что-то слева от себя и передает на вход чему-то справа. Этот оператор (называется "pipe" или "pipeline") используется для создания [функциональных конвейеров][pipes]. Вот пример:

```fsharp
let square x = x * x
let isOdd x = x % 2 <> 0

let getOddSquares items =
    items
    |> Seq.filter isOdd
    |> Seq.map square
```

Просматривая данный пример заметим, что `items` передается на вход функции `Seq.filter`. Возвращаемое значение `Seq.filter`, последовательность, затем передается на вход функции `Seq.map`. Результат выполнения `Seq.map` является выходным значением функции `getOddSquares`.

Использование конвейерного оператора -- это очень весело, и довольно редко можно увидеть F# код, которые не использует его. Это обычно почти самая любимая всеми возможность в списке F#.

# Типы в F#

Из-за того, что F# -- это язык платформы .NET, он использует те же примитивные типы, что и C#: `string`, `int` и так далее. Он также имеет .NET объекты и поддерживает четыре основных столпа объектно-ориентированного программирования. Так же присутствуют [кортежи][tuples] (tuples). F# также предоставляет два основных типа, которые невозможно найти в C#: [записи][records] (records) и [размеченные объединения][du] (discriminated unions).

Записи -- это именованные, сортированные объединения значений, которые содержат в себе операцию сравнения. И операцию сравнения мы имеем в виду в буквальном смысле. Нет необходимости различаться равенство ссылок или пользовательское определение равенства значения между двумя объектами. Записи -- это значения, и значения можно проверять на равенство. Они являются типами-произведениями, если говорить на языке теории категорий. Они имеют множество применений, однако одно из самых очевидных -- это знамена POCO и POJO.

```fsharp
open System

// Вот как вы можете определить тип-запись.
// Заметим, что вы можете использовать новые строки для обозначения новых меток.
type Person =
    { Name: string
      Age: int
      Birth: DateTime }

// Создать новую запись `Person` можно как-то так.
// Точка с запятой используютcя как разделитель между метками, если они расположены на одной строке.
let p1 = { Name="Charles"; Age=27; Birth=DateTime(1990, 1, 1) }

// Вот как мы используем переносы на новую строку для обозначения меток.
let p2 =
    { Name="Moulaye"
      Age=22
      Birth=DateTime(1995, 1, 1) }

// Записи можно сравнивать на равенство. Не нужно определять метод Equals() и GetHasCode().
printfn "Они равны? %b" (p1 = p2) // Это выведе `flase`, потому что они не одинаковые.
```

Другой основной тип в F# -- это [размеченные объединения, или DU][du]. DU -- это типы, представляющие некоторое количество именованных вариантов. На языке теории категорий это называется тип-сумма. Они также могут быть определены рекурсивно, что значительно упрощает иерархические данные.

```fsharp
// Определим обощенное бинарное дерево поиска.
//
// Заметим, что generic тип-параметр имеет ' в начале.
type BST<'T> =
    | Empty
    | Node of 'T * BST<'T> * BST<'T> // Каждый узел имеет левый и правый BST<'T>

// Перевернем BST с помощью сопоставления с образцом!
let rec flip bst =
    match bst with
    | Empty -> bst
    | Node(item, left, right) -> Node(item, flip right, flip left)

// Определим пример BST
let tree = 
    Node(10, 
        Node(3, 
            Empty, 
            Node(6, 
                Empty, 
                Empty)),
        Node(55,
            Node(16, 
                Empty,
                Empty),
            Empty))

// Перевернем его!
printfn "%A" (flip tree)
```

Та-да! Вооружившись мощью размеченных объединений и F#, вы можете пройти любое собеседование, в котором требуется перевернуть бинарное дерево поиска.

Вы можете также заметить немного занятного синтаксиса в определение варианта Node. Это на самом деле сигнатура кортежа. Это означает, что определенное нами BST, может быть или пустым, или кортежем `(значение, левое поддерево, правое поддерево). Прочитайте о [сигнатурах][signatures], чтобы узнать больше.

# Собираем все вместе: синтаксис F# за 60 секунд

Следующий пример кода представлен с разрешения [Скотта Влашина][scott], героя F# сообщества, написавшего этот прекрасный обзор F# синтаксиса. Вы прочтете его примерно за минуту. Пример был немного отредактирован.

```fsharp
// Данный код представлен с разрешения автора, Скотта Влашина. Он был немного модифицирован.
// Для однострочных комментариев используется двойной слеш. 
(* 
    Многострочные комментарии можно сделать вот так (хотя обычно используют двойной слеш).
*)

// ======== "Переменные" (на самом деле нет) ==========
// Ключевое слово "let" определяет неизменяемое (иммутабельное) значение
let myInt = 5
let myFloat = 3.14
let myString = "привет"   // заметьте, что типы не требуются

// ======== Списки ============
let twoToFive = [ 2; 3; 4; 5 ]        // Списки создаются с помощью квадратных скобок,
                                     // для разделения значений используются точки с запятой.
let oneToFive = 1 :: twoToFive   // :: создает список с новым первым элементом
// Результат: [1; 2; 3; 4; 5]

let zeroToFive = [0;1] @ twoToFive   // @ объединяет два списка

// ВАЖНО: запятые никогда не используются для разделения значений, только точки с запятой!

// ======== Функции ========
// Ключевое слово "let" также определяет именованную функцию.
let square x = x * x          // Заметьте, что скобки не используются.
square 3                      // А сейчас вызовем функцию. Снова, никаких скобок.

let add x y = x + y           // не используйте add (x,y)! Это означает
                              // совершенно другую вещь.
add 2 3                       // Вызовем фукнкцию.

// чтобы определить многострочную функцию, просто используйте отступы.
// Точки с запятой не требуются.
let evens list =
   let isEven x = x % 2 = 0     // Определет "isEven" как внутреннюю ("вложенную") функцию
   List.filter isEven list      // List.filter -- это библиотечная функция
                                // с двумя параметрами: логическая функция
                                // и список, которые требуется отфильтровать
  
evens oneToFive               // Вызовем функцию

// Вы можете использовать скобки, чтобы уточнить приоритет.
// В данном примере, сначала используем "map" с двумя аргументами,
// а потом вызываем "sum" для результата.
// Без скобок "List.map" была бы передана как аргумент в "List.sum"
let sumOfSquaresTo100 =
   List.sum (List.map square [ 1 .. 100 ])

// Вы можете передать результат одной функции в следующую с помощью "|>"
// Вот та же самая функция sumOfSquares, переписанная с помощью конвейера
let sumOfSquaresTo100piped =
   [ 1 .. 100 ] |> List.map square |> List.sum  // "square" определена раньше

// вы можете определять лямбда-функции (анонимные функции) 
// с помощью ключевого слова "fun"
let sumOfSquaresTo100withFun =
   [ 1 .. 100 ] |> List.map (fun x -> x * x) |> List.sum

// В F# возвращаемые значения неявные -- не требует слово "return"
// Функция всегда возвращает значение последнего использованого выражения.

// ======== Сопоставление с образцом ========
// Match..with.. -- это case/switch инструкции "на стероидах".
let x = "a"
match x with
| "a" -> printfn "x -- это a"
| "b" -> printfn "x -- это b"
| _ -> printfn "x -- это что-то другое"   // подчеркивание соответствует "чему угодно"

// Some(..) и None приблизительно соответствуют Nullable оберткам
let validValue = Some(99)
let invalidValue = None

// В данном примере, match..with сравнивает с "Some" и "None"
// и в то же время распаковывает значение в "Some".
let optionPatternMatch input =
   match input with
    | Some i -> printfn "целое число %d" i
    | None -> printfn "входное значение отсутствует"

optionPatternMatch validValue
optionPatternMatch invalidValue

// ========= Сложные типы данных =========

// Кортежи -- это пары значений, тройки значений и так далее.
// Кортежи используют запятые.
let twoTuple = (1, 2)
let threeTuple = ("a", 2, true)

// Записи имеют именованные поля. Точки с запятой являются разделителями.
type Person = { First: string; Last: string }

let person1 = { First="John"; Last="Doe" }
// Вы можете также использовать переносы на новую строку
// вместо точек с запятой.
let person2 =
    { First="Jane"
      Last="Doe" }

// Объединения преставляют варианты. Разделитель -- вертикальная черта.
type Temp = 
    | DegreesC of float
    | DegreesF of float

let temp = DegreesF 98.6

// Типы можно комбинировать рекурсивно различными путями.
// Например, вот тип-объединение, который содержит список
// элементов того же типа:
type Employee = 
  | Worker of Person
  | Manager of Employee list

let jdoe = { First="John"; Last="Doe" }
let worker = Worker jdoe

// ========= Вывод на экран =========
// Функции printf/printfn схожи с функциями Console.Write/WriteLine из C#.
printfn "Вывод на экран значений типа int %i, float %f, bool %b" 1 2.0 true
printfn "Строка %s, и что-то обобщенное %A" "hello" [ 1; 2; 3; 4 ]

// все сложные типы имеют встроенный красивый вывод
printfn "twoTuple=%A,\nPerson=%A,\nTemp=%A,\nEmployee=%A" 
twoTuple person1 temp worker
```

В дополнение, в нашей официальной документации для .NET и поддерживаемых языков есть материал ["Tour F#"][tour].

# Что делать дальше

В этом посте описывается большое количество вещей, однако это только поверхностные возможности F#. Мы надеемся, что после прочтения этой статьи, вы сможете погрузиться в F# и функциональное программирование. Есть несколько вещей, которые мы рекомендуем сделать во время дальнейшего изучения F#:

- Используйте F#, чтобы построить [прекрасные фрактальные деревья][fractal-trees].
- Используйте F# для исследования и анализа [данных о вселенной Симпсонов][simpsons] в Azure Notebooks.
- Используйте F# и [Suave][suave] для разработки [веб-приложений][music-store].
- Используйте F# при разработке serverless-приложений и компонентов с помощью [Azure Functions][azure-functions]. 

Есть много-много других вещей, для которых вы можете использовать F#, предыдущий список ни в коем случае не является исчерпывающим. F# используется в различных приложениях: от простых [скриптов для сборки][fake], до бэкенда [веб-магазинов с миллиардной выручкой][jet]. Нет никаких ограничений по проектам, для которых вы можете использовать F#.

# Дополнительные ресурсы

Стоит отметить, что имеется большое число информации для обучения F#, включая материалы для тех, кто пришел с опытом C# или Java. Следующие ссылки могут быть полезными по мере того, как вы будете глубже изучать F#:

- [F# Guide][guide]
- [F# for Fun and Profit][fun-profit]
- [F# Wiki][wikibook]
- [Learn X in Y Minutes: F#][learnxiny]

Также существуют несколько документированных способов [начать изучать F#][get-started].

И наконец, F# сообществе очень дружелюбно к начинающим. Есть очень активный чат в Slack, поддерживаемый F# Software Foundation, с комнатами для начинающих, к которым вы [можете свободно присоединиться][fssf-slack]. Мы настоятельно рекомендуем вам это сделать!

[why-you-should-use]: https://blogs.msdn.microsoft.com/dotnet/2017/05/31/why-you-should-use-f/
[statements]: https://ru.wikipedia.org/wiki/Оператор_(программирование)
[expressions]: https://ru.wikipedia.org/wiki/Выражение_(информатика)
[types]: https://ru.wikipedia.org/wiki/Тип_данных
[mutables]: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/#mutable-variables
[ref-transparency]: http://wiki.c2.com/?ReferentialTransparency
[cond-expr]: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/conditional-expressions-if-then-else
[unit]: https://docs.microsoft.com/ru-ru/dotnet/fsharp/language-reference/unit-type
[arrays]: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/arrays
[lists]: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/lists
[seqs]: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/sequences
[pipes]: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/index#function-composition-and-pipelining
[tuples]: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/tuples
[records]: https://docs.microsoft.com/ru-ru/dotnet/fsharp/language-reference/records
[du]: https://docs.microsoft.com/ru-ru/dotnet/fsharp/language-reference/discriminated-unions
[signatures]: https://fsharpforfunandprofit.com/posts/function-signatures/
[fractal-trees]: https://github.com/sfsharp/dojo-fractal-forest
[simpsons]: https://www.kaggle.com/wcukierski/the-simpsons-by-the-data
[suave]: https://suave.io/
[music-store]: https://theimowski.gitbooks.io/suave-music-store/content/en/
[azure-functions]: https://docs.microsoft.com/azure/azure-functions/functions-reference-fsharp
[fake]: https://www.hanselman.com/blog/ExploringFAKEAnFBuildSystemForAllOfNET.aspx
[jet]: https://tech.jet.com/blog/tag/f/ 
[guide]: https://docs.microsoft.com/ru-ru/dotnet/fsharp/]
[fun-profit]: https://swlaschin.gitbooks.io/fsharpforfunandprofit/content/
[wikibook]: https://en.wikibooks.org/wiki/F_Sharp_Programming
[learnxiny]: https://learnxinyminutes.com/docs/fsharp/
[get-started]: https://docs.microsoft.com/en-us/dotnet/fsharp/get-started/
[fssf-slack]: http://foundation.fsharp.org/join
[scott]: https://twitter.com/ScottWlaschin
[tour]: https://docs.microsoft.com/ru-ru/dotnet/fsharp/tour