# Начни изучать F#. Пособие для C# разработчиков

В одном из наших предыдущих постов, "Почему вам следует использовать F#", перечислены несколько причин, почему F# стоит попробовать уже сегодня. В данной статье мы разберем некоторые основы, необходимые для успешного применения F#. Данный пост предназначен для людей, которые приходят из C#, Java или имеют иной опыт объектно-ориентированного программирования. Понятия, представленны здесь, должны быть уже хорошо знакомы F# программистам.

В данном посте не будут предприниматься попытки показать, как вы можете "переписать" C# код на F#. Это связано с тем, что C# и F# представляют различные парадигмы, что делает каждый язык подходящим для своих собственных целей. Мы думаем, что изучение понятия функционального программирования расширит кругозор и поможет вам быть лучшим программистом. Вы осознаете ценность функционального программирования быстрее, если не будете думать о том, как переписать код из одной парадигмы в другую.

А сейчас пришло время быть любопытным, пытливым, и быть готовым к изучению совершенно новых вещей. Давайте начнем!

# Сразу к различиям

Перед тем как мы приступим к изучению понятий функционального программирования, давайте посмотрим на небольшой пример F# кода и определим несколько мест, в которых F# отличается от C#. Это базовый пример кода на F# с двумя функциями и выводом результата на экран:

```fsharp
let square x = x * x

let sumOfSquares n =
    [1..n] // Создадим список с элементами от 1 до n
    |> List.map square // Возведем в квадрат каждый элемент
    |> List.sum // Просуммируем их!

printfn "Сумма квадратов первых 5 натуральных чисел равна %d" (sumOfSquares 5)
```

Заметим, что здесь нет явного указания типов, отсутствуют точки с запятой или фигурные скобки. Скобки используются в единственном месте: для вызова функции `sumOfSquares` с числом 5 в качестве входного значения и последующего вывода результата на экран. Конвейерный оператор (pipeline operator) используется так же как конвейеры (каналы) в Unix. `square` -- это функция, которая передается напрямую как параметр в функцию `List.map` (такие функции рассматриваются как значения, first-class functions).

Хотя здесь намного больше различий, о которых мы можем поговорить, здесь происходят более глубокие вещи, и именно они являются ключем к пониманию F#.

# Соответствие ключевых понятий C# и ключевых понятий F#

Следующая таблица показывает основные соответствия между некоторым ключевыми понятиями C# и F#. Это умышленно короткое и неполное описание, но так его проще запомнить в начале изучения F#.

| C# и Объектно-Ориентированное Программирование | F# и Функциональное Программирование |
| --- | --- |
| Переменные | Неизменяемые значения |
| Инструкции | Выражения |
| Объекты с методами | Типы и функции |

Быстрая шпаргалка по некоторым терминам:

**Переменные** -- это значения, которые могуть изменяться на месте или варьироваться. Это следует из их названия!

**Неизменяемые значения** -- это значения, которые не могут быть изменены после присваивания.

**Инструкции** -- это единицы работы, выполняемые императивно, путем запуска программы.

**Выражения** -- это единицы кода, которые можно вычислить и получить значения.

**Типы** -- это классификация данных в программе.

Стоит отметить, что все указанное в столбце C# так же возможно в F# (и довольно легко реализуется). В столбце F# так же есть вещи, которые возможны в C#, хотя их намного сложнее достигнуть. Следует упомянуть, что элементы в левом столбце не являются "плохими" в F#, и наоборот. Объекты с методами отлично подходят для использования в F#, и часто являются лучшим решением для F# в зависимости от вашей ситуации.

## Неизменяемые значения вместо переменных

Одним из наиболее преобразующих понятий в функциональном программировании является неизменяемость (immutability). Этому понятию часто уделяют недостаточно внимания в сообществе любителей функционального программирования. Но если вы никогда не использовали язык, в котором значения неизменяемы по умолчанию, то это часто является первым и наиболее значимым препятствием для дальнейшего изучения. Почти все функциональные языки в своем основании имеют неизменяемость.

```fsharp
let x = 1
```

В предыдущем выражении значение 1 связано с именем `x`. В течение всего времени существования имя `x` теперь ссылается на значение 1 и не может быть изменено. Например, следующий код не может переназначить значение `x`:

```fsharp
let x = 1
x = x + 1 // Это выражение ничего не присваивает!
```

Вместо этого, вторая строка является сравнением, определяющим является ли `x` равным `x + 1`. Хотя существует способ изменить (mutate) `x` с помощью использования оператора `<-` и модификатора `mutable` (см. подробности в Mutable Variables), вы быстро поймете, что проще думать решении задач без переприсвоения значений. Это позволяет вам играть на сильных сторонах F#, вместо использования его словно любой другой императивный язык программирования.

Мы сказали о том, что неизменяемость является преобразующей, и это означает, что существуют практические различия в подходах к решению задач. Например, циклы `for` и другие базовые операции в императивном программировании не так часто используются в F#.

Рассмотрим более конкретный пример, скажем, вы хотите возвести в квадрат числа из входного списка. Вот способ как это можно сделать в F#:

```fsharp
// Определим функцию, которая вычисляет квадрат значения
let square x = x * x

let getSquares items =
    items |> List.map square
	
let lst = [ 1; 2; 3; 4; 5 ] // Создать спискок в F#

printfn "Квадрат числа %A равен %A" lst (getSquares lst)
```

Заметим, что в этом примере нет цикла `for`. На концептуальном уровне это очень отличается от императивного кода. Мы не возводим в квадрат каждый элемент списка. Мы с помощью функции `square` отображаем входной список, чтобы получить значения, возведенные в квадрат. Это очень тонкое различие, но на практике может приводить к значительно отличающемуся коду. Прежде всего, функция `getSquares` на самом деле создает целиком новый список.

Неизменяемость делает больше, чем просто меняет способ управления данными в списках. Понятие ссылочной прозрачности (Referential Transparency) естественным образом возникает в F#, и это ???, как системы разрабатываются и как части этих систем сочетаются. Функциональные характеристики системы становятся более предсказумыми из-за того, что значения не изменяются, когда вы этого не ожидаете.

Более того, когда значения неизменяемы, конкурентное программирование становится проще. Из-за того, что значения не могут быть изменены, некоторые сложные проблемы, которые вы можете встретить в С#, не встречаются в F#. Хотя использование F# не решит магическим образом все ваши проблемы с многопоточностью и асинхронностью, оно сделаем многие вещи проще.