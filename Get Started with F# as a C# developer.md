# Начни изучать F#. Пособие для C# разработчиков

В одном из наших предыдущих постов, "Почему вам следует использовать F#", перечислены несколько причин, почему F# стоит попробовать уже сегодня. В данной статье мы разберем некоторые основы, необходимые для успешного применения F#. Данный пост предназначен для людей, которые приходят из C#, Java или имеют иной опыт объектно-ориентированного программирования. Понятия, представленны здесь, должны быть уже хорошо знакомы F# программистам.

В данном посте не будут предприниматься попытки показать, как вы можете "переписать" C# код на F#. Это связано с тем, что C# и F# представляют различные парадигмы, что делает каждый язык подходящим для своих собственных целей. Мы думаем, что изучение понятия функционального программирования расширит кругозор и поможет вам быть лучшим программистом. Вы осознаете ценность функционального программирования быстрее, если не будете думать о том, как переписать код из одной парадигмы в другую.

А сейчас пришло время быть любопытным, пытливым, и быть готовым к изучению совершенно новых вещей. Давайте начнем!

# Сразу к различиям

Перед тем как мы приступим к изучению понятий функционального программирования, давайте посмотрим на небольшой пример F# кода и определим несколько мест, в которых F# отличается от C#. Это базовый пример кода на F# с двумя функциями и выводом результата на экран:

```fsharp
let square x = x * x

let sumOfSquares n =
    [1..n] // Создадим список с элементами от 1 до n
    |> List.map square // Возведем в квадрат каждый элемент
    |> List.sum // Просуммируем их!

printfn "Сумма квадратов первых 5 натуральных чисел равна %d" (sumOfSquares 5)
```

Заметим, что здесь нет явного указания типов, отсутствуют точки с запятой или фигурные скобки. Скобки используются в единственном месте: для вызова функции `sumOfSquares` с числом 5 в качестве входного значения и последующего вывода результата на экран. Конвейерный оператор (pipeline operator) используется так же как конвейеры (каналы) в Unix. `square` -- это функция, которая передается напрямую как параметр в функцию `List.map` (такие функции рассматриваются как значения, first-class functions).

Хотя здесь намного больше различий, о которых мы можем поговорить, здесь происходят более глубокие вещи, и именно они являются ключем к пониманию F#.

# Соответствие ключевых понятий C# и ключевых понятий F#

Следующая таблица показывает основные соответствия между некоторым ключевыми понятиями C# и F#. Это умышленно короткое и неполное описание, но так его проще запомнить в начале изучения F#.

| C# и Объектно-Ориентированное Программирование | F# и Функциональное Программирование |
| --- | --- |
| Переменные | Неизменяемые значения |
| Инструкции | Выражения |
| Объекты с методами | Типы и функции |

Быстрая шпаргалка по некоторым терминам:

**Переменные** -- это значения, которые могуть изменяться на месте или варьироваться. Это следует из их названия!

**Неизменяемые значения** -- это значения, которые не могут быть изменены после присваивания.

**Инструкции** -- это единицы работы, выполняемые императивно, путем запуска программы.

**Выражения** -- это единицы кода, которые можно вычислить и получить значения.

**Типы** -- это классификация данных в программе.

Стоит отметить, что все указанное в столбце C# так же возможно в F# (и довольно легко реализуется). В столбце F# так же есть вещи, которые возможны в C#, хотя их намного сложнее достигнуть. Следует упомянуть, что элементы в левом столбце не являются "плохими" в F#, и наоборот. Объекты с методами отлично подходят для использования в F#, и часто являются лучшим решением для F# в зависимости от вашей ситуации.

## Неизменяемые значения вместо переменных

Одним из наиболее преобразующих понятий в функциональном программировании является неизменяемость (immutability). Этому понятию часто уделяют недостаточно внимания в сообществе любителей функционального программирования. Но если вы никогда не использовали язык, в котором значения неизменяемы по умолчанию, то это часто является первым и наиболее значимым препятствием для дальнейшего изучения. Почти все функциональные языки в своем основании имеют неизменяемость.

```fsharp
let x = 1
```

В предыдущем выражении значение 1 связано с именем `x`. В течение всего времени существования имя `x` теперь ссылается на значение 1 и не может быть изменено. Например, следующий код не может переназначить значение `x`:

```fsharp
let x = 1
x = x + 1 // Это выражение ничего не присваивает!
```

Вместо этого, вторая строка является сравнением, определяющим является ли `x` равным `x + 1`. Хотя существует способ изменить (mutate) `x` с помощью использования оператора `<-` и модификатора `mutable` (см. подробности в Mutable Variables), вы быстро поймете, что проще думать решении задач без переприсвоения значений. Это позволяет вам играть на сильных сторонах F#, вместо использования его словно любой другой императивный язык программирования.

Мы сказали о том, что неизменяемость является преобразующей, и это означает, что существуют практические различия в подходах к решению задач. Например, циклы `for` и другие базовые операции в императивном программировании не так часто используются в F#.

Рассмотрим более конкретный пример, скажем, вы хотите возвести в квадрат числа из входного списка. Вот способ как это можно сделать в F#:

```fsharp
// Определим функцию, которая вычисляет квадрат значения
let square x = x * x

let getSquares items =
    items |> List.map square
	
let lst = [ 1; 2; 3; 4; 5 ] // Создать список в F#

printfn "Квадрат числа %A равен %A" lst (getSquares lst)
```

Заметим, что в этом примере нет цикла `for`. На концептуальном уровне это очень отличается от императивного кода. Мы не возводим в квадрат каждый элемент списка. Мы с помощью функции `square` отображаем входной список, чтобы получить значения, возведенные в квадрат. Это очень тонкое различие, но на практике может приводить к значительно отличающемуся коду. Прежде всего, функция `getSquares` на самом деле создает целиком новый список.

Неизменяемость делает больше, чем просто меняет способ управления данными в списках. Понятие ссылочной прозрачности (Referential Transparency) естественным образом возникает в F#, и это ???, как системы разрабатываются и как части этих систем сочетаются. Функциональные характеристики системы становятся более предсказумыми из-за того, что значения не изменяются, когда вы этого не ожидаете.

Более того, когда значения неизменяемы, конкурентное программирование становится проще. Из-за того, что значения не могут быть изменены, некоторые сложные проблемы, которые вы можете встретить в С#, не встречаются в F#. Хотя использование F# не решит магическим образом все ваши проблемы с многопоточностью и асинхронностью, оно сделаем многие вещи проще.

# Выражения вместо инструкций

Как было упомянуто ранее, F# использует выражения (expressions). Это контрастирует с C#, где используются инструкции (statements) практически для всего. Различие между ними может казаться на первый взгляд незначительным, однако есть одна вещь, которую следует держать в голове: выражения производят значения. Инструкции -- нет.

```fsharp
// 'getMessage' -- это функция, и `name` -- ее входной параметр.
let getMessage name =
    if name = "Phillip" then   // 'if' -- это выражение.
        "Hello, Phillip!"      // Эта строка тоже является выражением. Оно возвращает значение
    else
        "Hello, other person!" // То же самое с этой строкой.

let phillipMessage = getMessage "Phillip" // getMessage, при вызове, является выражением. Его значение связано с именем 'phillipMessage'.
let alfMessage = getMessage "Alf" // Это выражение связано с именем 'alfMessage'!
``` 

В предыдущем примере вы можете увидеть несколько вещей, которые отличают F# от императивных языков вроде C#:

- `if...then...else` -- это выражение, а не инструкция.
- Каждая ветка выражения `if` возвращает значением, которые в данном случае является возвращаемым значением функции `getMessage`.
- Каждый вызов функции `getMessage` -- это выражение, которое берет строку и возвращает строку.

Хотя это очень отличается от C#, вам скорее всего покажется естественным при написании кода на F#.

Если рассмотреть немного глубже, F# на самом деле использует выражения для моделирования инструкций. Такие выражения возвращают значения типа `unit`. `unit` немного похож на `void` в C#:

```fsharp
let names = [ "Alf"; "Vasily"; "Shreyans"; "Jin Sun"; "Moulaye" ]

// Цикл `for`.  Ключевое слово 'do' указывает, что выражение их внутренней области видмости должно иметь тип `unit`.
// Если это не так, то результат выражения неявно игнорируется.
for name in names do
printfn "My name is %s" name // printfn возвращает unit.
```

В предыдущем примере выражения `for`, все имеет тип `unit`. Выражения `unit` -- это выражения, которые не имеют возвращаемого значения.

# Массивы, списки и последовательности в F#

Предыдущие примеры кода использовали массивы и списки F#. В данном разделе разъясняются некоторые подробности.

F# предоставляет несколько типов коллекций и самые распространенные из них -- это массивы, списки и последовательности.

- Массив в F# -- это массивы .NET. Они изменяемые, что означает, что из значения могут быть изменены на месте. Они вычисляются энергично (eagerly).
- Списки в F# -- это неизменяемые односвязные списки. Они могут быть использованы в виде `list patterns` для сопоставлением с образом (pattern matching) в F#. Они вычисляются энергично.
- Последовательности в F# является неизменяемыми `IEnumerable<T>`. Они вычисляются лениво.

Массивы, списки и последовательности в F# также имеют особый синтаксис для выражений. Это очень удобно для различных задач, где вы можете генерировать данные коллекции программным путем.

```fsharp
// Генерировать 100 чисел возведенных в квадрат как F# список.
let first100Squares = [ for x in 1..100 -> x * x ]

// То же самое, но массив!
let first100SquaresArray = [| for x in 1..100 -> x * x |]

// Функция, которая генерирует бесконечную последовательность все нечетные числа.
//
// Вызывать вместе с  Seq.take!
let odds = 
    let rec loop x = // Использует рекурсивную локальную функцию
        seq { yield x
              yield! loop (x + 2) }
    loop 1

printfn "Первые 3 нечетных числа: %A" (Seq.take 3 odds)
// Вывод:  "Первые 3 нечетных числа: seq [1; 3; 5]
```

# Соответствие между LINQ методами и F# функциями

Если вы знакомы с LINQ методами, то следующая таблица поможет вам понять аналогичные функции в F#.

| LINQ | F# функция |
| --- | --- |
| `Where` | `filter` |
| `Select` | `map` |
| `GroupBy` | `groupBy` |
| `SelectMany` | `collect` |
| `Aggregate` | `fold` или `reduce` |
| `Sum` | `sum` |

Вы также можете заметить, что такой же набор функций существует для модуля `Seq`, модуля `List` и модуля `Array`. Функции модуля `Seq` могут быть использованы для последовательностей, спиской или массивов. Функции для массивов и списков могут быть использованы только для массив и списков в F# соответственно. Также последовательности в F# ленивые, а списки и массив -- энергичные. Использование функций модуля `Seq` на списках или массивах влечет за собой ленивое вычисление, а тип возвращаемого значения будет последовательностью.

Хотя предудыщий раздел содержит в себе довольно много всего, это станет интуитивным, когда вы будете больше писать на F#.

# Функциональные конвейеры

Вы могли заметить, что `|>` используется в предыдущих примерах кода. Этот оператор очень похож на конвейеры в unix: он берет что-то слева от себя и передает на вход чему-то справа. Этот оператор (называется "pipe" или "pipeline") используется для создания функциональных конвйеров. Вот пример:

```fsharp
let square x = x * x
let isOdd x = x % 2 <> 0

let getOddSquares items =
    items
    |> Seq.filter isOdd
    |> Seq.map square
```

Просматривая данный пример заметим, что `items` передается на вход функции `Seq.filter`. Возвращаемое значение `Seq.filter`, последовательность, затем передается на вход функции `Seq.map`. Результат выполнения `Seq.map` является выходным значением функции `getOddSquares`.

Использование конвейерного оператора -- это очень весело, и довольно редко можно увидеть F# код, которые не использует его. Это обычно почти самая любимая всеми возможность в списке F#.

# Типа в F#

Из-за того, что F# -- это язык платформы .NET, он использует те же примитивные типы, что и C#: `string`, `int` и так далее. Он также имеет .NET объекты и поддерживает четыре основных столпа объектно-ориентированного программирования. Так же присутствуют кортежи (tuples). F# также предоставляет два основных типа, которые невозможно найти в C#: записи (records) и размеченные объединения (discriminated unions).

Записи -- это именованные, сортированные объединения значений, которые содержат в себе операцию сравнения. И операцию сравнения мы имеем в виду в буквальном смысле. Нет необходимости различаться равенство ссылок или пользовательское определение равенства значения между двумя объектами. Записи -- это значения, и значения можно проверять на равенство. Они являются типами-произведениями, если говорить на языке теории категорий. Они имеют множество применений, однако одно из самых очевидных -- это знаменя POCO и POJO.

```fsharp
open System

// Вот как вы можете определить тип-запись.
// Заметим, что вы можете использовать новые строки для обозначения новых меток.
type Person =
    { Name: string
      Age: int
      Birth: DateTime }

// Создать новую запись `Person` можно как-то так.
// Точки с запятой используют как разделитель между метками, если она расположены на одной строке.
let p1 = { Name="Charles"; Age=27; Birth=DateTime(1990, 1, 1) }

// Вот как мы используем переносы на новую строку для обозначения меток.
let p2 =
    { Name="Moulaye"
      Age=22
      Birth=DateTime(1995, 1, 1) }

// Записи можно сравнивать на равенство. Не нужно определять метод Equals() и GetHasCode().
printfn "Они равны? %b" (p1 = p2) // Это выведе `flase`, потому что они не одинаковые.
```